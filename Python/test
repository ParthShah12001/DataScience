var SessionTimeout = function SessionTimeout() { }.prototype = {
    _redirectTimer: null,
    _warningTimer: null,
    _lastTouched: new Date(),
    _timeout: 30,
    _istimeOut: false,

    _setSessionTimers: function () {

        if (!this._timeout) {
            this._timeout = 30;
        }

        var mins = this._timeout;
        var timeToRedirect = mins * 30 * 1000;
        var timeToShowWarning = Math.max(mins - 5, Math.floor(mins * 0.75)) * 30 * 1000;

        // clear previous timers
        clearTimeout(this._redirectTimer);
        clearTimeout(this._warningTimer);

        // setup timers
        this._warningTimer = setTimeout(this._displaySessionTimeoutWarning, timeToShowWarning, this);
        this._redirectTimer = setTimeout(this._redirectToLogOff, timeToRedirect);
    },
    _displaySessionTimeoutWarning: function (sessionTimeout) {
        var Modals = require("Services/Modals");
        var Labels = EY.Fact.Resources.Labels;

        SessionTimeout._istimeOut = true;

        var dialog = Modals.ShowAlert({
            okBtnText: Labels.OK,
            titleText: Labels.SessionTimeoutTitle,
            text: Labels.LogOutWarningMessage.replace("{0}", sessionTimeout.LastTouchedMinutes()),
            notificationType: Modals.NotificationTypes.info,
            context: this
        });
        dialog.done(function () {
            SessionTimeout.TouchSession();
            if (!(SessionTimeout.LastTouchedMinutes() > 1)) {
                Modals.HideAddNewUserPopUp(true);
            }
        }),
            dialog.fail(function () {
                //do nothing
                return;
            });
    },
    _redirectToLogOff: function () {
        // Check to see if the _dataChange was set and if not then set it to false
        // since we have not started tracking the changes and or we are not on the engagement
        // form. Also if the _dataChanged is set to true then we still want to set it to false
        // since we are invoking the navigation away logic and we don't want the user to
        // give any input about navigating away.
        if (typeof _dataChanged == "undefined" || _dataChanged === true) {
            _dataChanged = false;
        }

        var watcher = require("Services/ChangeWatcher");
        var tooltip = require("Services/Behaviors/ToolTip");
        window.sessionStorage.setItem("lasturl", window.location.href);
        watcher.deleteSavedFilters();
        tooltip.destroyToolTip();
        watcher.reset();
        $.when(watcher.unlock().done(function () {
            window.location = '/#Timeout';
        }).fail(function (response) {
            Logger.log("Failed Unlock:" + response);
            window.location = 'App/Error';
        }));

    },
    Initialize: function (timeoutMinutes) {
        this._timeout = timeoutMinutes;
        this.Reset();
    },
    Reset: function () {
        // Let's update the time on the server first
        // and then update the local window timers
        // since we don't know how long it will take to update server
        // session timeout values.
        this.TouchSession();
        this._setSessionTimers();
    },
    ResetOnly: function () {
        this._setSessionTimers();
    },
    LastTouchedMinutes: function () {
        return Math.round((new Date() - this._lastTouched) / 30 / 1000);
    },
    TouchSession: function () {
        if (this.LastTouchedMinutes() > 1) {
            $.get("App/Touch");
            // Reset the timers so that we are in sync with the server session timeout
            this.ResetOnly();
            this._lastTouched = new Date();
        }
    }
};
// Session time-out
$("body").bind("click keypress", function () {
    SessionTimeout.Reset();
});
